{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MPH MPH ( M INQUE for P artitioning H eritability) is a C++ program for fast REML estimation of genetic variance components. The method has the following properties: It is fast and memory-efficient. It has robust convergence. It supports the analyses of dominance, epistasis, and genetic correlation. It can perform complex genome-partitioning of quantitative genetic variation. Citation TBA License MPH is distributed under the GPL-3.0 license . Author and contact Jicai Jiang If you want to submit a issue concerning the software please do so using the MPH Github repository .","title":"Home"},{"location":"#mph","text":"MPH ( M INQUE for P artitioning H eritability) is a C++ program for fast REML estimation of genetic variance components. The method has the following properties: It is fast and memory-efficient. It has robust convergence. It supports the analyses of dominance, epistasis, and genetic correlation. It can perform complex genome-partitioning of quantitative genetic variation.","title":"MPH"},{"location":"#citation","text":"TBA","title":"Citation"},{"location":"#license","text":"MPH is distributed under the GPL-3.0 license .","title":"License"},{"location":"#author-and-contact","text":"Jicai Jiang If you want to submit a issue concerning the software please do so using the MPH Github repository .","title":"Author and contact"},{"location":"examples/","text":"Note All utility scripts used in the examples are described in Utilities . Simulated datasets QTL-MAS 2012 The data set is available for download here . This article describes how the data set was simulated. 3k related animals, 10k SNPs, 5 chromosomes, and 3 traits Sequence genotypes The data set is available for download here . Sequence genotypes were simulated by genosim . 10k unrelated individuals, 5M sequence variants, and 30 chromosomes Functional annotations were quickly simulated by assigning LDSC baseline annotations to the simulated sequence variants in order. Phenotypes were simulated using the S-LDSC baseline model enrichment estimates for human traits . The enrichment estimates were used to compute variance component (VC) estimates for intercept and 24 main functional annotations. The VC estimates were set as true values in phenotype simulation . A small value was added to the intercept's VC to enhance the all-in-one GRM's positive definiteness. Partitioning heritability By chromosomes Partitioning heritability by chromosomes for the QTL-MAS 2012 dataset Create a SNP info file : chr.snp_info.csv . Make a GRM for each chromosome. Create a GRM list : chr.grms.txt . Run REML/MINQUE . # Making GRMs # Input: geno and chr.snp_info.csv mkdir chromosomes for chr in {1..5} do mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --snp_weight $chr --num_threads 10 --out ./chromosomes/$chr done # Running REML # Input: chr.grms.txt, phen.csv, and covar.csv mph --minque --grm_list chr.grms.txt --phenotype phen.csv --trait milk --error_weight milk_wt --covariate_file covar.csv --covariate_names all --num_threads 10 --out ./chromosomes/milk By functional annotations Partitioning heritability by functional annotations for the sequence genotypes dataset # 1. Create a new SNP info file including only variants that pass quality control. # SNPs with an MAF < 0.01 are removed from funct.snp_info.csv, producing qc.funct.snp_info.csv. snpinfo=\"qc.funct.snp_info.csv\" # Read the first line of the SNP info file and split it by a comma to get the annotation list. IFS=',' read -ra elements < $snpinfo # 2. Make a GRM for each functional annotation category. # It may take about one hour to contruct all the GRMs. # Note that precomputed GRMs are included in the dataset. Go to the step 3 to save time. mkdir grms # Iterate over the list of annotation categories. # Use PLINK to extract SNPs in each category for faster I/O. for ((i = 1; i < ${#elements[@]}; i++)); do awk -F ',' -v colname=\"${elements[i]}\" 'NR == 1 { for (j = 1; j <= NF; j++) if ($j == colname) col = j } NR > 1 && $col == 1 { print $1 }' $snpinfo > \"${elements[i]}.extract.txt\" plink --bfile geno --chr-set 30 --extract \"${elements[i]}.extract.txt\" --threads 14 --make-bed --out ${elements[i]} mph --make_grm --binary_geno ${elements[i]} --snp_info $snpinfo --snp_weight ${elements[i]} --num_threads 14 --out ./grms/${elements[i]} rm ${elements[i]}.* done # 3. Create a GRM list and run REML. # Create a GRM list. grmlist=\"funct.grms.txt\" if [ -e $grmlist ]; then rm $grmlist fi for ((i = 1; i < ${#elements[@]}; i++)); do echo \"grms/${elements[i]} 1\" >> $grmlist done # Run REML. mkdir reml mph --minque --save_memory --grm_list $grmlist --phenotype pheno/hsq0.9.sim.csv --trait 1 --num_threads 14 --out reml/1 Below is an R script for recalculating the proportion of genetic variance explained and enrichments and visualization. source(\"mph_functs.R\") library(data.table) # Read the SNP info file to get the SNP weighting matrix. sw = as.matrix(fread(\"qc.funct.snp_info.csv\"),rownames=1) sw[is.na(sw)] = 0 # Get the SNP incidence matrix. # The SNP weighting matrix is often the incidence matrix, but not always. si = (sw != 0) * 1 # More annotation categories can be included in the incidence matrix. gene = as.numeric( rowSums(si[, c(\"Coding_UCSC\", \"Intron_UCSC\", \"Promoter_UCSC\", \"UTR_3_UCSC\", \"UTR_5_UCSC\")]) > 0 ) si = cbind(si, gene) annot_size = colSums(si) # Calculate the crossproduct of si and sw. # The columns of sw should match the rows of vcfile. index = 1:25; sw = sw[, index] cp = crossprod(si, sw) vcfile = \"reml/1.mq.vc.csv\" result = recalculate_enrichments(vcfile, cp, annot.size=annot_size) result # plot library(ggplot2) result = as.data.frame(result[-1,]) pct = result$prop * 100 pct = round(pct,2) rownames(result) = paste0(rownames(result),\" (\",pct,\"%)\") df = data.frame(FunctionalAnnotation=rownames(result), Enrichment=result$enrichment, SE=result$enrichment.se) p<- ggplot(df, aes(x=FunctionalAnnotation, y=Enrichment)) + geom_bar(stat=\"identity\", color=\"black\", position=position_dodge()) + geom_errorbar(aes(ymin=Enrichment-SE, ymax=Enrichment+SE), width=.5, position=position_dodge(.9)) p<- p + theme(text = element_text(size=22), axis.text.x = element_text(angle = 65, vjust = 1, hjust=1)) p<- p+ geom_hline(yintercept=1, linetype=\"dashed\", color = \"red\") + xlab(\"\") + ylab(\"Per-SNP heritability enrichment estimate\") + ggtitle(\"Trait 1\") p The following figure will be produced. Dominance and epistasis Decomposing genetic variance into additive, dominance, and epistatic components for the QTL-MAS 2012 dataset Make GRMs from SNPs : one for additive and one for dominance. Create a GRM list for --make_fore : AD.grms.txt . Make first-order interaction GRMs . Create a GRM list for --minque , listing A, D, AxA, AxD, and DxD: ADE.grms.txt . Run REML/MINQUE . # Making one additive GRM and one dominance GRM # Input: geno and chr.snp_info.csv mkdir nonadditive mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./nonadditive/test mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./nonadditive/test --dom # Making three first-order interaction GRMs # Input: AD.grms.txt listing the GRMs that have been made mph --make_fore --grm_list AD.grms.txt --num_threads 10 --out ./nonadditive/test # Running REML # Input: ADE.grms.txt, phen.csv, and covar.csv mph --minque --grm_list ADE.grms.txt --phenotype phen.csv --trait milk --covariate_file covar.csv --covariate_names all --num_threads 10 --out ./nonadditive/milk Genetic correlation Estimating genetic and environmental correlations for the QTL-MAS 2012 dataset Bivariate REML can be transformed into univariate REML. Though MPH is designed for univariate REML, it can effectively do bivariate REML when provided with correct GRMs. Genome-wide Make a new phenotype file and a new covariate file for a pair of traits. Make three GRMs and two residual covariance matrices for a pair of traits. Run REML using a GRM list file like this . Compute the genetic correlation estimate from the VC estimates. mkdir bivarREML Rscript --no-save make_pheno_for_pair.R phen.csv milk fat ./bivarREML/test Rscript --no-save make_covariate_for_pair.R covar.csv ./bivarREML/test.covar.csv mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./bivarREML/test Rscript --no-save make_grms_for_pair.R ./bivarREML/test ./bivarREML/test Rscript --no-save make_rescov_for_pair.R ./bivarREML/test ./bivarREML/test mph --minque --save_mem --grm_list bivar.grms.txt --phenotype ./bivarREML/test.milk.fat.pheno.csv --trait scaled --covariate_file ./bivarREML/test.covar.csv --covariate_names all --num_threads 10 --out ./bivarREML/milk.fat Below is an R script for computing between-trait correlation estimates from the .mq.vc.csv output file. vc = read.csv(\"./bivarREML/milk.fat.mq.vc.csv\") # Calculate the genetic correlation estimate and SE. x1 = vc[1,3] x2 = vc[2,3] x12 = vc[3,3] var_x1 = vc[1,14] var_x2 = vc[2,15] var_x12 = vc[3,16] cov_x1_x2 = vc[1,15] cov_x1_x12 = vc[1,16] cov_x2_x12 = vc[2,16] gcorr = x12 / sqrt(x1 * x2) var_gcorr = gcorr**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) se_gcorr = sqrt(var_gcorr) # Calculate the environmental correlation estimate and SE. x1 = vc[4,3] + vc[6,3] x2 = vc[6,3] x12 = vc[5,3] var_x1 = vc[4,17] + vc[6,4] **2 + 2*vc[6,17] var_x2 = vc[6,4] **2 var_x12 = vc[5,18] cov_x1_x2 = vc[6,17] + vc[6,4] **2 cov_x1_x12 = vc[4,18] + vc[6,18] cov_x2_x12 = vc[6,18] ecorr = x12 / sqrt(x1 * x2) var_ecorr = ecorr**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) se_ecorr = sqrt(var_ecorr) Chromosome-wise Make a new phenotype file and a new covariate file for a pair of traits. Make 15 GRMs (three for each chromosome) and two residual covariance matrices for a pair of traits. Run REML using a GRM list file like this . Compute the genetic correlation estimates from the VC estimates. mkdir bivarREML Rscript --no-save make_pheno_for_pair.R phen.csv milk fat ./bivarREML/test Rscript --no-save make_covariate_for_pair.R covar.csv ./bivarREML/test.covar.csv for chr in {1..5} do mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --snp_weight $chr --num_threads 10 --out ./bivarREML/$chr Rscript --no-save make_grms_for_pair.R ./bivarREML/$chr ./bivarREML/$chr done Rscript --no-save make_rescov_for_pair.R ./bivarREML/test ./bivarREML/test mph --minque --save_mem --grm_list bivar.chr.grms.txt --phenotype ./bivarREML/test.milk.fat.pheno.csv --trait scaled --covariate_file ./bivarREML/test.covar.csv --covariate_names all --num_threads 10 --out ./bivarREML/chr.milk.fat Below is an Rscript for computing chromosome-wise genetic correlations between traits. vc = read.csv(\"./bivarREML/chr.milk.fat.mq.vc.csv\") # Calculate the genetic correlation estimate and SE. gcorr = matrix(nrow=nrow(vc)/3-1, ncol=2) for (k in 1:nrow(gcorr)) { x1 = vc[1+(k-1)*3,3] x2 = vc[2+(k-1)*3,3] x12 = vc[3+(k-1)*3,3] var_x1 = vc[1+(k-1)*3, 8+nrow(vc)+(k-1)*3] var_x2 = vc[2+(k-1)*3, 8+nrow(vc)+1+(k-1)*3] var_x12 = vc[3+(k-1)*3,8+nrow(vc)+2+(k-1)*3] cov_x1_x2 = vc[1+(k-1)*3, 8+nrow(vc)+1+(k-1)*3] cov_x1_x12 = vc[1+(k-1)*3, 8+nrow(vc)+2+(k-1)*3] cov_x2_x12 = vc[2+(k-1)*3, 8+nrow(vc)+2+(k-1)*3] est = x12 / sqrt(x1 * x2) var_est = est**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) gcorr[k, 1] = est gcorr[k, 2] = sqrt(var_est) }","title":"Examples"},{"location":"examples/#simulated-datasets","text":"","title":"Simulated datasets"},{"location":"examples/#qtl-mas-2012","text":"The data set is available for download here . This article describes how the data set was simulated. 3k related animals, 10k SNPs, 5 chromosomes, and 3 traits","title":"QTL-MAS 2012"},{"location":"examples/#sequence-genotypes","text":"The data set is available for download here . Sequence genotypes were simulated by genosim . 10k unrelated individuals, 5M sequence variants, and 30 chromosomes Functional annotations were quickly simulated by assigning LDSC baseline annotations to the simulated sequence variants in order. Phenotypes were simulated using the S-LDSC baseline model enrichment estimates for human traits . The enrichment estimates were used to compute variance component (VC) estimates for intercept and 24 main functional annotations. The VC estimates were set as true values in phenotype simulation . A small value was added to the intercept's VC to enhance the all-in-one GRM's positive definiteness.","title":"Sequence genotypes"},{"location":"examples/#partitioning-heritability","text":"","title":"Partitioning heritability"},{"location":"examples/#by-chromosomes","text":"Partitioning heritability by chromosomes for the QTL-MAS 2012 dataset Create a SNP info file : chr.snp_info.csv . Make a GRM for each chromosome. Create a GRM list : chr.grms.txt . Run REML/MINQUE . # Making GRMs # Input: geno and chr.snp_info.csv mkdir chromosomes for chr in {1..5} do mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --snp_weight $chr --num_threads 10 --out ./chromosomes/$chr done # Running REML # Input: chr.grms.txt, phen.csv, and covar.csv mph --minque --grm_list chr.grms.txt --phenotype phen.csv --trait milk --error_weight milk_wt --covariate_file covar.csv --covariate_names all --num_threads 10 --out ./chromosomes/milk","title":"By chromosomes"},{"location":"examples/#by-functional-annotations","text":"Partitioning heritability by functional annotations for the sequence genotypes dataset # 1. Create a new SNP info file including only variants that pass quality control. # SNPs with an MAF < 0.01 are removed from funct.snp_info.csv, producing qc.funct.snp_info.csv. snpinfo=\"qc.funct.snp_info.csv\" # Read the first line of the SNP info file and split it by a comma to get the annotation list. IFS=',' read -ra elements < $snpinfo # 2. Make a GRM for each functional annotation category. # It may take about one hour to contruct all the GRMs. # Note that precomputed GRMs are included in the dataset. Go to the step 3 to save time. mkdir grms # Iterate over the list of annotation categories. # Use PLINK to extract SNPs in each category for faster I/O. for ((i = 1; i < ${#elements[@]}; i++)); do awk -F ',' -v colname=\"${elements[i]}\" 'NR == 1 { for (j = 1; j <= NF; j++) if ($j == colname) col = j } NR > 1 && $col == 1 { print $1 }' $snpinfo > \"${elements[i]}.extract.txt\" plink --bfile geno --chr-set 30 --extract \"${elements[i]}.extract.txt\" --threads 14 --make-bed --out ${elements[i]} mph --make_grm --binary_geno ${elements[i]} --snp_info $snpinfo --snp_weight ${elements[i]} --num_threads 14 --out ./grms/${elements[i]} rm ${elements[i]}.* done # 3. Create a GRM list and run REML. # Create a GRM list. grmlist=\"funct.grms.txt\" if [ -e $grmlist ]; then rm $grmlist fi for ((i = 1; i < ${#elements[@]}; i++)); do echo \"grms/${elements[i]} 1\" >> $grmlist done # Run REML. mkdir reml mph --minque --save_memory --grm_list $grmlist --phenotype pheno/hsq0.9.sim.csv --trait 1 --num_threads 14 --out reml/1 Below is an R script for recalculating the proportion of genetic variance explained and enrichments and visualization. source(\"mph_functs.R\") library(data.table) # Read the SNP info file to get the SNP weighting matrix. sw = as.matrix(fread(\"qc.funct.snp_info.csv\"),rownames=1) sw[is.na(sw)] = 0 # Get the SNP incidence matrix. # The SNP weighting matrix is often the incidence matrix, but not always. si = (sw != 0) * 1 # More annotation categories can be included in the incidence matrix. gene = as.numeric( rowSums(si[, c(\"Coding_UCSC\", \"Intron_UCSC\", \"Promoter_UCSC\", \"UTR_3_UCSC\", \"UTR_5_UCSC\")]) > 0 ) si = cbind(si, gene) annot_size = colSums(si) # Calculate the crossproduct of si and sw. # The columns of sw should match the rows of vcfile. index = 1:25; sw = sw[, index] cp = crossprod(si, sw) vcfile = \"reml/1.mq.vc.csv\" result = recalculate_enrichments(vcfile, cp, annot.size=annot_size) result # plot library(ggplot2) result = as.data.frame(result[-1,]) pct = result$prop * 100 pct = round(pct,2) rownames(result) = paste0(rownames(result),\" (\",pct,\"%)\") df = data.frame(FunctionalAnnotation=rownames(result), Enrichment=result$enrichment, SE=result$enrichment.se) p<- ggplot(df, aes(x=FunctionalAnnotation, y=Enrichment)) + geom_bar(stat=\"identity\", color=\"black\", position=position_dodge()) + geom_errorbar(aes(ymin=Enrichment-SE, ymax=Enrichment+SE), width=.5, position=position_dodge(.9)) p<- p + theme(text = element_text(size=22), axis.text.x = element_text(angle = 65, vjust = 1, hjust=1)) p<- p+ geom_hline(yintercept=1, linetype=\"dashed\", color = \"red\") + xlab(\"\") + ylab(\"Per-SNP heritability enrichment estimate\") + ggtitle(\"Trait 1\") p The following figure will be produced.","title":"By functional annotations"},{"location":"examples/#dominance-and-epistasis","text":"Decomposing genetic variance into additive, dominance, and epistatic components for the QTL-MAS 2012 dataset Make GRMs from SNPs : one for additive and one for dominance. Create a GRM list for --make_fore : AD.grms.txt . Make first-order interaction GRMs . Create a GRM list for --minque , listing A, D, AxA, AxD, and DxD: ADE.grms.txt . Run REML/MINQUE . # Making one additive GRM and one dominance GRM # Input: geno and chr.snp_info.csv mkdir nonadditive mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./nonadditive/test mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./nonadditive/test --dom # Making three first-order interaction GRMs # Input: AD.grms.txt listing the GRMs that have been made mph --make_fore --grm_list AD.grms.txt --num_threads 10 --out ./nonadditive/test # Running REML # Input: ADE.grms.txt, phen.csv, and covar.csv mph --minque --grm_list ADE.grms.txt --phenotype phen.csv --trait milk --covariate_file covar.csv --covariate_names all --num_threads 10 --out ./nonadditive/milk","title":"Dominance and epistasis"},{"location":"examples/#genetic-correlation","text":"Estimating genetic and environmental correlations for the QTL-MAS 2012 dataset Bivariate REML can be transformed into univariate REML. Though MPH is designed for univariate REML, it can effectively do bivariate REML when provided with correct GRMs.","title":"Genetic correlation"},{"location":"examples/#genome-wide","text":"Make a new phenotype file and a new covariate file for a pair of traits. Make three GRMs and two residual covariance matrices for a pair of traits. Run REML using a GRM list file like this . Compute the genetic correlation estimate from the VC estimates. mkdir bivarREML Rscript --no-save make_pheno_for_pair.R phen.csv milk fat ./bivarREML/test Rscript --no-save make_covariate_for_pair.R covar.csv ./bivarREML/test.covar.csv mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --num_threads 10 --out ./bivarREML/test Rscript --no-save make_grms_for_pair.R ./bivarREML/test ./bivarREML/test Rscript --no-save make_rescov_for_pair.R ./bivarREML/test ./bivarREML/test mph --minque --save_mem --grm_list bivar.grms.txt --phenotype ./bivarREML/test.milk.fat.pheno.csv --trait scaled --covariate_file ./bivarREML/test.covar.csv --covariate_names all --num_threads 10 --out ./bivarREML/milk.fat Below is an R script for computing between-trait correlation estimates from the .mq.vc.csv output file. vc = read.csv(\"./bivarREML/milk.fat.mq.vc.csv\") # Calculate the genetic correlation estimate and SE. x1 = vc[1,3] x2 = vc[2,3] x12 = vc[3,3] var_x1 = vc[1,14] var_x2 = vc[2,15] var_x12 = vc[3,16] cov_x1_x2 = vc[1,15] cov_x1_x12 = vc[1,16] cov_x2_x12 = vc[2,16] gcorr = x12 / sqrt(x1 * x2) var_gcorr = gcorr**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) se_gcorr = sqrt(var_gcorr) # Calculate the environmental correlation estimate and SE. x1 = vc[4,3] + vc[6,3] x2 = vc[6,3] x12 = vc[5,3] var_x1 = vc[4,17] + vc[6,4] **2 + 2*vc[6,17] var_x2 = vc[6,4] **2 var_x12 = vc[5,18] cov_x1_x2 = vc[6,17] + vc[6,4] **2 cov_x1_x12 = vc[4,18] + vc[6,18] cov_x2_x12 = vc[6,18] ecorr = x12 / sqrt(x1 * x2) var_ecorr = ecorr**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) se_ecorr = sqrt(var_ecorr)","title":"Genome-wide"},{"location":"examples/#chromosome-wise","text":"Make a new phenotype file and a new covariate file for a pair of traits. Make 15 GRMs (three for each chromosome) and two residual covariance matrices for a pair of traits. Run REML using a GRM list file like this . Compute the genetic correlation estimates from the VC estimates. mkdir bivarREML Rscript --no-save make_pheno_for_pair.R phen.csv milk fat ./bivarREML/test Rscript --no-save make_covariate_for_pair.R covar.csv ./bivarREML/test.covar.csv for chr in {1..5} do mph --make_grm --binary_genotype geno --min_maf 0 --min_hwe_pval 1e-8 --snp_info chr.snp_info.csv --snp_weight $chr --num_threads 10 --out ./bivarREML/$chr Rscript --no-save make_grms_for_pair.R ./bivarREML/$chr ./bivarREML/$chr done Rscript --no-save make_rescov_for_pair.R ./bivarREML/test ./bivarREML/test mph --minque --save_mem --grm_list bivar.chr.grms.txt --phenotype ./bivarREML/test.milk.fat.pheno.csv --trait scaled --covariate_file ./bivarREML/test.covar.csv --covariate_names all --num_threads 10 --out ./bivarREML/chr.milk.fat Below is an Rscript for computing chromosome-wise genetic correlations between traits. vc = read.csv(\"./bivarREML/chr.milk.fat.mq.vc.csv\") # Calculate the genetic correlation estimate and SE. gcorr = matrix(nrow=nrow(vc)/3-1, ncol=2) for (k in 1:nrow(gcorr)) { x1 = vc[1+(k-1)*3,3] x2 = vc[2+(k-1)*3,3] x12 = vc[3+(k-1)*3,3] var_x1 = vc[1+(k-1)*3, 8+nrow(vc)+(k-1)*3] var_x2 = vc[2+(k-1)*3, 8+nrow(vc)+1+(k-1)*3] var_x12 = vc[3+(k-1)*3,8+nrow(vc)+2+(k-1)*3] cov_x1_x2 = vc[1+(k-1)*3, 8+nrow(vc)+1+(k-1)*3] cov_x1_x12 = vc[1+(k-1)*3, 8+nrow(vc)+2+(k-1)*3] cov_x2_x12 = vc[2+(k-1)*3, 8+nrow(vc)+2+(k-1)*3] est = x12 / sqrt(x1 * x2) var_est = est**2 * ( var_x1/(4 * x1**2) + var_x2/(4 * x2**2) + var_x12/x12**2 + cov_x1_x2/(2*x1*x2) - cov_x1_x12/(x1*x12) - cov_x2_x12/(x2*x12) ) gcorr[k, 1] = est gcorr[k, 2] = sqrt(var_est) }","title":"Chromosome-wise"},{"location":"install/","text":"Source code The mph source code is hosted on Github . Installation Binary executables Binary executables are available in the Releases . mph is statically compiled with Intel oneAPI Base & HPC Toolkit 2023.1 and Eigen 3.4.0 on Ubuntu 22. mph should be executable. Type chmod +x mph on the command line if needed. Compilation of mph Requirements Linux x86_64 Intel oneAPI Base & HPC Toolkit Eigen >= 3.4.0 Change the Eigen path in Makefile . On the command line type make while in the directory containing the Makefile . This should produce the executable named mph . For Windows Windows Subsystem for Linux (WSL) can be used to run MPH on a Windows machine. Install Linux on Windows with WSL Ubuntu will be installed by default, and other Linux distributions are available. Run pre-compiled MPH binaries on a WSL Linux distribution as on a Linux machine.","title":"Install"},{"location":"install/#source-code","text":"The mph source code is hosted on Github .","title":"Source code"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#binary-executables","text":"Binary executables are available in the Releases . mph is statically compiled with Intel oneAPI Base & HPC Toolkit 2023.1 and Eigen 3.4.0 on Ubuntu 22. mph should be executable. Type chmod +x mph on the command line if needed.","title":"Binary executables"},{"location":"install/#compilation-of-mph","text":"Requirements Linux x86_64 Intel oneAPI Base & HPC Toolkit Eigen >= 3.4.0 Change the Eigen path in Makefile . On the command line type make while in the directory containing the Makefile . This should produce the executable named mph .","title":"Compilation of mph"},{"location":"install/#for-windows","text":"Windows Subsystem for Linux (WSL) can be used to run MPH on a Windows machine. Install Linux on Windows with WSL Ubuntu will be installed by default, and other Linux distributions are available. Run pre-compiled MPH binaries on a WSL Linux distribution as on a Linux machine.","title":"For Windows"},{"location":"options/","text":"Note Option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option; e.g., --phenotype works the same as --phenotype_file . Making a GRM from SNPs Input Option Argument Type Description --binary_genotype_file FILE PREFIX Required PLINK bed/bim/fam filename prefix --snp_info_file FILE Required SNP info file in CSV format --snp_weight_name STRING Optional Must be a column header in the SNP info file and specify which column to use for weighting SNPs in a GRM. If not set, all variants in the SNP info file will be used with a weight of 1. --min_maf FLOAT Optional Filter out all variants with minor allele frequency (MAF) less than or equal to the provided threshold [default=0] --min_hwe_pval FLOAT Optional Filter out all variants which have Hardy-Weinberg equilibrium exact test p-value below the provided threshold [default=0] Genotype files MPH uses PLINK bim/fam/bed files for genotypes. The bed/bim/fam file format is described on the PLINK website . SNP info file The SNP info file is a CSV file with a header line. The first column must list SNP IDs. Each of the other columns corresponds to one GRM and each row corresponds to a SNP. If a SNP does not belong to a GRM, leave the corresponding cell empty . If a SNP belongs to n GRMs, put 1 in each of the n cells. To partition SNP heritability by functional annotations , create a SNP info file in which each column (or GRM) represents a category of a functional annotation. Functional annotations may overlap; for example, if a SNP belongs to 6 functional annotation categories, put 1 in each of those 6 cells. In the example of partitioning heritability by chromosomes , chr.snp_info.csv has five columns for five chromosomes. Options Option Argument Type Description --make_grm FLAG Required To make a GRM from genotypes --dominance FLAG Optional Flag to make a dominance GRM rather than an additive GRM --num_threads INT Optional Number of computational threads to use [default=1] Output Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix Two files will be generated for a GRM: one with the suffix .grm.iid and the other with .grm.bin . Making a GRM from GRMs Input Option Argument Type Description --grm_list FILE Required Space-delimited text file listing GRMs that have been made The GRM list file is a space-delimited text file, such as AD.grms.txt . It has no header and one or two columns. The first column must be the file path for each GRM. The second column is optional and can be a short GRM identifier for --make_fore and --make_core . Options Option Argument Type Description --merge_grms FLAG Optional Flag to merge a list of GRMs --deduct_grms FLAG Optional Flag to deduct the subsequent GRMs from the first in a list --make_fore FLAG Optional Flag to make first-order interaction GRMs --make_core FLAG Optional Flag to make GRMs for covariances between random effects --num_threads INT Optional Number of computational threads to use [default=1] If a SNP is used in multiple GRMs, the SNP will be treated to be multiple identical SNPs in the resulting GRM of --merge_grms . Output Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix --merge_grms and --deduct_grms generate one GRM. --make_fore generates n ( n +1)/2 GRMs for n GRMs in a GRM list. --make_core generates n ( n -1)/2 GRMs for n GRMs in a GRM list. REML/MINQUE Input Option Argument Type Description --grm_list FILE Required Space-delimited text file listing GRMs that have been made --phenotype_file FILE Required Phenotype file in CSV format --trait STRING Required Must be a column header in the phenotype file and specify which trait to analyze --error_weight_name STRING Optional Must be a column header in the phenotype file and specify which column contains individual error variance weights --covariate_file FILE Optional Covariate file in CSV format --covariate_names STRING Optional Comma-separated list of covariates to include in the analysis GRM list file The GRM list file is a space-delimited text file, such as chr.grms.txt . It has no header and one or two columns. The first column must be the file path for each GRM. The second column is optional and can list an initial variance component (VC) value for each GRM. Phenotype file The phenotype file is a CSV file with a header line. The first column must be the individual ID. The header line needs to contain trait names. Missing values of phenotypes need to be left empty. Do not use space, -9, NA, or NaN. MPH has --error_weight_name to accommodate individual reliabilies ( r 2 ) for pseudo-phenotypes (e.g., de-regressed estimated breeding values). The error weights can be set to 1/ r 2 -1 and kept as a column of the phenotype file. Covariate file The covariate file is a CSV file with a header line. The first column must be the individual ID. The header line needs to contain covariate names. Missing values of covariates need to be left empty. Do not use space, -9, NA, or NaN. If --covariate_names all is specified, MPH will use as covariates all columns from the 2nd to the last in the covariate file. Options Option Argument Type Description --minque FLAG Required Flag to run REML or iterative MINQUE --save_memory FLAG Optional Flag to enable the memory-saving mode --num_threads INT Optional Number of computational threads to use [default=1] --heritability FLOAT Optional Initial heritability value in REML iterations [default=0.5] --exact_init FLAG Optional Flag to set initial VC values to the exact values of the GRM list file's second column rather than their ratios --num_iterations INT Optional Max number of REML iterations [default=20] --tol FLOAT Optional Absolute convergence tolerance for REML log-likelihood [default=0.01] --num_random_vectors INT Optional Number of random probing vectors for stochastic trace estimation [default=100] --seed INT Optional Random seed in stochastic trace estimation [default=0] To force MINQUE(0) or MINQUE(1), set --num_iterations 1 . The second column of the GRM list file should be set to 0 for MINQUE(0) and 1 for MINQUE(1). The memory-saving mode (--save_memory) is not necessarily slower, particularly on a solid-state drive. Output Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix Four files are generated, as shown below. Filename suffix Description .mq.blue.csv Best linear unbiased estimates of fixed effects .mq.iter.csv Summary of REML iterations .mq.vc.csv Variance component estimates .mq.py.csv Residuals of the linear mixed model .mq.vc.csv has the following columns. Column Description name Name of the variance component or GRM m Weighted number of SNPs in the GRM var Estimate of the variance component seV Standard error of the variance component estimate pve Estimate of the proportion of variance explained seP Standard error of the estimate of the proportion of variance explained enrichment Estimate of the per-SNP heritability enrichment seE Standard error of the estimate of the per-SNP heritability enrichment Simulation Simulating phenotypes based on a list of GRMs mph --simulate --num_phenotypes 100 --grm_list chr.grms.txt --heritability 0.5 --output sim_pheno In the i th row of the GRM list file are GRM( i ) and VC( i ). MPH simulates total genetic values ( g ) by sampling g from N( 0 , V ) in which V is equal to the sum of all GRM( i )*VC( i ). MPH further simulates phenotypes by adding an error term ( e ) to g based on heritability. Prediction Empirical best linear unbiased predictions (EBLUPs) mph --pred --mq_file milk.chr --output milk.chr MPH computes EBLUPs using the output of --minque and outputs them to a file with a suffix of .mq.blup.csv. For genomic partitioning, EBLUPs are the estimates of direct genomic values. General relationship matrix The --grm_list file can list any general relationship matrix, not necessarily a genomic relationship matrix. Scripts are provided to convert a general relationship matrix to the MPH format.","title":"Documentation"},{"location":"options/#making-a-grm-from-snps","text":"","title":"Making a GRM from SNPs"},{"location":"options/#input","text":"Option Argument Type Description --binary_genotype_file FILE PREFIX Required PLINK bed/bim/fam filename prefix --snp_info_file FILE Required SNP info file in CSV format --snp_weight_name STRING Optional Must be a column header in the SNP info file and specify which column to use for weighting SNPs in a GRM. If not set, all variants in the SNP info file will be used with a weight of 1. --min_maf FLOAT Optional Filter out all variants with minor allele frequency (MAF) less than or equal to the provided threshold [default=0] --min_hwe_pval FLOAT Optional Filter out all variants which have Hardy-Weinberg equilibrium exact test p-value below the provided threshold [default=0]","title":"Input"},{"location":"options/#genotype-files","text":"MPH uses PLINK bim/fam/bed files for genotypes. The bed/bim/fam file format is described on the PLINK website .","title":"Genotype files"},{"location":"options/#snp-info-file","text":"The SNP info file is a CSV file with a header line. The first column must list SNP IDs. Each of the other columns corresponds to one GRM and each row corresponds to a SNP. If a SNP does not belong to a GRM, leave the corresponding cell empty . If a SNP belongs to n GRMs, put 1 in each of the n cells. To partition SNP heritability by functional annotations , create a SNP info file in which each column (or GRM) represents a category of a functional annotation. Functional annotations may overlap; for example, if a SNP belongs to 6 functional annotation categories, put 1 in each of those 6 cells. In the example of partitioning heritability by chromosomes , chr.snp_info.csv has five columns for five chromosomes.","title":"SNP info file"},{"location":"options/#options","text":"Option Argument Type Description --make_grm FLAG Required To make a GRM from genotypes --dominance FLAG Optional Flag to make a dominance GRM rather than an additive GRM --num_threads INT Optional Number of computational threads to use [default=1]","title":"Options"},{"location":"options/#output","text":"Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix Two files will be generated for a GRM: one with the suffix .grm.iid and the other with .grm.bin .","title":"Output"},{"location":"options/#making-a-grm-from-grms","text":"","title":"Making a GRM from GRMs"},{"location":"options/#input_1","text":"Option Argument Type Description --grm_list FILE Required Space-delimited text file listing GRMs that have been made The GRM list file is a space-delimited text file, such as AD.grms.txt . It has no header and one or two columns. The first column must be the file path for each GRM. The second column is optional and can be a short GRM identifier for --make_fore and --make_core .","title":"Input"},{"location":"options/#options_1","text":"Option Argument Type Description --merge_grms FLAG Optional Flag to merge a list of GRMs --deduct_grms FLAG Optional Flag to deduct the subsequent GRMs from the first in a list --make_fore FLAG Optional Flag to make first-order interaction GRMs --make_core FLAG Optional Flag to make GRMs for covariances between random effects --num_threads INT Optional Number of computational threads to use [default=1] If a SNP is used in multiple GRMs, the SNP will be treated to be multiple identical SNPs in the resulting GRM of --merge_grms .","title":"Options"},{"location":"options/#output_1","text":"Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix --merge_grms and --deduct_grms generate one GRM. --make_fore generates n ( n +1)/2 GRMs for n GRMs in a GRM list. --make_core generates n ( n -1)/2 GRMs for n GRMs in a GRM list.","title":"Output"},{"location":"options/#remlminque","text":"","title":"REML/MINQUE"},{"location":"options/#input_2","text":"Option Argument Type Description --grm_list FILE Required Space-delimited text file listing GRMs that have been made --phenotype_file FILE Required Phenotype file in CSV format --trait STRING Required Must be a column header in the phenotype file and specify which trait to analyze --error_weight_name STRING Optional Must be a column header in the phenotype file and specify which column contains individual error variance weights --covariate_file FILE Optional Covariate file in CSV format --covariate_names STRING Optional Comma-separated list of covariates to include in the analysis","title":"Input"},{"location":"options/#grm-list-file","text":"The GRM list file is a space-delimited text file, such as chr.grms.txt . It has no header and one or two columns. The first column must be the file path for each GRM. The second column is optional and can list an initial variance component (VC) value for each GRM.","title":"GRM list file"},{"location":"options/#phenotype-file","text":"The phenotype file is a CSV file with a header line. The first column must be the individual ID. The header line needs to contain trait names. Missing values of phenotypes need to be left empty. Do not use space, -9, NA, or NaN. MPH has --error_weight_name to accommodate individual reliabilies ( r 2 ) for pseudo-phenotypes (e.g., de-regressed estimated breeding values). The error weights can be set to 1/ r 2 -1 and kept as a column of the phenotype file.","title":"Phenotype file"},{"location":"options/#covariate-file","text":"The covariate file is a CSV file with a header line. The first column must be the individual ID. The header line needs to contain covariate names. Missing values of covariates need to be left empty. Do not use space, -9, NA, or NaN. If --covariate_names all is specified, MPH will use as covariates all columns from the 2nd to the last in the covariate file.","title":"Covariate file"},{"location":"options/#options_2","text":"Option Argument Type Description --minque FLAG Required Flag to run REML or iterative MINQUE --save_memory FLAG Optional Flag to enable the memory-saving mode --num_threads INT Optional Number of computational threads to use [default=1] --heritability FLOAT Optional Initial heritability value in REML iterations [default=0.5] --exact_init FLAG Optional Flag to set initial VC values to the exact values of the GRM list file's second column rather than their ratios --num_iterations INT Optional Max number of REML iterations [default=20] --tol FLOAT Optional Absolute convergence tolerance for REML log-likelihood [default=0.01] --num_random_vectors INT Optional Number of random probing vectors for stochastic trace estimation [default=100] --seed INT Optional Random seed in stochastic trace estimation [default=0] To force MINQUE(0) or MINQUE(1), set --num_iterations 1 . The second column of the GRM list file should be set to 0 for MINQUE(0) and 1 for MINQUE(1). The memory-saving mode (--save_memory) is not necessarily slower, particularly on a solid-state drive.","title":"Options"},{"location":"options/#output_2","text":"Option Argument Type Description --output_file FILE PREFIX Required Output filename prefix Four files are generated, as shown below. Filename suffix Description .mq.blue.csv Best linear unbiased estimates of fixed effects .mq.iter.csv Summary of REML iterations .mq.vc.csv Variance component estimates .mq.py.csv Residuals of the linear mixed model .mq.vc.csv has the following columns. Column Description name Name of the variance component or GRM m Weighted number of SNPs in the GRM var Estimate of the variance component seV Standard error of the variance component estimate pve Estimate of the proportion of variance explained seP Standard error of the estimate of the proportion of variance explained enrichment Estimate of the per-SNP heritability enrichment seE Standard error of the estimate of the per-SNP heritability enrichment","title":"Output"},{"location":"options/#simulation","text":"Simulating phenotypes based on a list of GRMs mph --simulate --num_phenotypes 100 --grm_list chr.grms.txt --heritability 0.5 --output sim_pheno In the i th row of the GRM list file are GRM( i ) and VC( i ). MPH simulates total genetic values ( g ) by sampling g from N( 0 , V ) in which V is equal to the sum of all GRM( i )*VC( i ). MPH further simulates phenotypes by adding an error term ( e ) to g based on heritability.","title":"Simulation"},{"location":"options/#prediction","text":"Empirical best linear unbiased predictions (EBLUPs) mph --pred --mq_file milk.chr --output milk.chr MPH computes EBLUPs using the output of --minque and outputs them to a file with a suffix of .mq.blup.csv. For genomic partitioning, EBLUPs are the estimates of direct genomic values.","title":"Prediction"},{"location":"options/#general-relationship-matrix","text":"The --grm_list file can list any general relationship matrix, not necessarily a genomic relationship matrix. Scripts are provided to convert a general relationship matrix to the MPH format.","title":"General relationship matrix"},{"location":"performance/","text":"Performance","title":"Performance"},{"location":"performance/#performance","text":"","title":"Performance"},{"location":"util/","text":"Note Utility scripts are hosted in the MPH repository . GRM input/output MPH computes only genomic relationship matrices. External general relationship matrices can be converted to MPH format for use in MPH. mph_functs.R contains two R functions for GRM input/output. write_grm() writes an R GRM into MPH format files (.iid and .bin). read_grm() reads an MPH GRM into R. The R matrix to be written can be any general relationship matrix. This script is sourced in other R scripts for GRM input/output. grm_txt2bin.R converts a relationship matrix from txt to MPH binary format. Rscript --no-save grm_txt2bin.R example.grm.txt example This input file should be structured like example.grm.txt . AGHmatrix2mph.R constructs a numerator relationship matrix with AGHmatrix and writes it into MPH format files. Making files for a trait pair Four R scripts are provided to prepare input files for bivariate REML in MPH. make_pheno_for_pair.R generates new phenotype and covariate files for a trait pair. A covariate file should always be used in MPH's bivariate REML. If no covariate file exists initially, use the one generated by make_pheno_for_pair.R . make_covariate_for_pair.R generates a new covariate file for a trait pair. If an original covariate file exists, use the new one generated by make_covariate_for_pair.R . make_grms_for_pair.R generates three GRMs for a trait pair: One for the variance of trait 1 ( .G11 ) One for the variance of trait 2 ( .G22 ) One for the covariance between them ( .G12 ) make_rescov_for_pair.R generates two residual covariance matrices for a trait pair: One for the difference between the environmental variances of traits 1 and 2 ( .E1d ) The other for the environmental covariance between them ( .E12 ) Usage examples are available here . Heritability enrichment Making a SNP info file A Perl script, make_snp_info.pl , is provided to create the SNP info file . Usage: perl make_snp_info.pl PLINK-bim-file functional-annotation-file output-filename-prefix Both input files should be in plain text format without header lines. Functional-annotation-file's first four columns should be chrom, start, end, and category. Example: perl make_snp_info.pl test.bim test.annot.txt test The input files are test.bim and test.annot.txt . An output file named test.snp_info.csv will be generated. From VCs to enrichments The .mq.vc.csv file produced by mph --minque contains the estimates and SEs of VCs, PVEs, and enrichments, where PVEs and enrichments are valid only when functional annotation categories do not overlap with one another. If functional categories actually overlap, one more quick computation is needed to recalculate PVEs and enrichments from .mq.vc.csv and the SNP info file . This can be quickly done by the recalculate_enrichments() function in mph_functs.R . recalculate_enrichments(vcfile, crossprod, nsnps=NA, annot.size=NA) vcfile: the .mq.vc.csv file produced by mph --minque . crossprod: the crossproduct of SNP incidence matrix and SNP weighting matrix. Its row names and columns should match the annotation categories of interest and the rows of vcfile, respectively. nsnps: the total number of SNPs. If NA , it is set to the first GRM's number of SNPs in vcfile. annot.size: a list of the number of SNPs in each annotation category listed in the row names of crossprod. It can be computed from the column-wise sum of the corresponding SNP incidence matrix. If NA , it is set to the m column of vcfile. A usage example is available here .","title":"Utilities"},{"location":"util/#grm-inputoutput","text":"MPH computes only genomic relationship matrices. External general relationship matrices can be converted to MPH format for use in MPH. mph_functs.R contains two R functions for GRM input/output. write_grm() writes an R GRM into MPH format files (.iid and .bin). read_grm() reads an MPH GRM into R. The R matrix to be written can be any general relationship matrix. This script is sourced in other R scripts for GRM input/output. grm_txt2bin.R converts a relationship matrix from txt to MPH binary format. Rscript --no-save grm_txt2bin.R example.grm.txt example This input file should be structured like example.grm.txt . AGHmatrix2mph.R constructs a numerator relationship matrix with AGHmatrix and writes it into MPH format files.","title":"GRM input/output"},{"location":"util/#making-files-for-a-trait-pair","text":"Four R scripts are provided to prepare input files for bivariate REML in MPH. make_pheno_for_pair.R generates new phenotype and covariate files for a trait pair. A covariate file should always be used in MPH's bivariate REML. If no covariate file exists initially, use the one generated by make_pheno_for_pair.R . make_covariate_for_pair.R generates a new covariate file for a trait pair. If an original covariate file exists, use the new one generated by make_covariate_for_pair.R . make_grms_for_pair.R generates three GRMs for a trait pair: One for the variance of trait 1 ( .G11 ) One for the variance of trait 2 ( .G22 ) One for the covariance between them ( .G12 ) make_rescov_for_pair.R generates two residual covariance matrices for a trait pair: One for the difference between the environmental variances of traits 1 and 2 ( .E1d ) The other for the environmental covariance between them ( .E12 ) Usage examples are available here .","title":"Making files for a trait pair"},{"location":"util/#heritability-enrichment","text":"","title":"Heritability enrichment"},{"location":"util/#making-a-snp-info-file","text":"A Perl script, make_snp_info.pl , is provided to create the SNP info file . Usage: perl make_snp_info.pl PLINK-bim-file functional-annotation-file output-filename-prefix Both input files should be in plain text format without header lines. Functional-annotation-file's first four columns should be chrom, start, end, and category. Example: perl make_snp_info.pl test.bim test.annot.txt test The input files are test.bim and test.annot.txt . An output file named test.snp_info.csv will be generated.","title":"Making a SNP info file"},{"location":"util/#from-vcs-to-enrichments","text":"The .mq.vc.csv file produced by mph --minque contains the estimates and SEs of VCs, PVEs, and enrichments, where PVEs and enrichments are valid only when functional annotation categories do not overlap with one another. If functional categories actually overlap, one more quick computation is needed to recalculate PVEs and enrichments from .mq.vc.csv and the SNP info file . This can be quickly done by the recalculate_enrichments() function in mph_functs.R . recalculate_enrichments(vcfile, crossprod, nsnps=NA, annot.size=NA) vcfile: the .mq.vc.csv file produced by mph --minque . crossprod: the crossproduct of SNP incidence matrix and SNP weighting matrix. Its row names and columns should match the annotation categories of interest and the rows of vcfile, respectively. nsnps: the total number of SNPs. If NA , it is set to the first GRM's number of SNPs in vcfile. annot.size: a list of the number of SNPs in each annotation category listed in the row names of crossprod. It can be computed from the column-wise sum of the corresponding SNP incidence matrix. If NA , it is set to the m column of vcfile. A usage example is available here .","title":"From VCs to enrichments"}]}